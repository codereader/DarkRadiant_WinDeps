// -*- c++ -*-
// Generated by gtkmmproc -- DO NOT MODIFY!
#ifndef _GIOMM_APPLICATIONCOMMANDLINE_H
#define _GIOMM_APPLICATIONCOMMANDLINE_H


#include <glibmm/ustring.h>
#include <sigc++/sigc++.h>

/* Copyright (C) 2010 Jonathon Jongsma <jonathon@quotidian.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <glibmm/object.h>
#include <glibmm/variant.h>


#ifndef DOXYGEN_SHOULD_SKIP_THIS
typedef struct _GApplicationCommandLine GApplicationCommandLine;
typedef struct _GApplicationCommandLineClass GApplicationCommandLineClass;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gio
{ class ApplicationCommandLine_Class; } // namespace Gio
namespace Gio
{

/** ApplicationCommandLine - A command-line invocation of an application.
 * ApplicationCommandLine represents a command-line invocation of an
 * application. It is created by Application and emitted in the "command-line"
 * signal and virtual function.
 *
 * The class contains the list of arguments that the program was invoked with.
 * It is also possible to query if the commandline invocation was local (ie:
 * the current process is running in direct response to the invocation) or
 * remote (ie: some other process forwarded the commandline to this process).
 *
 * The ApplicationCommandLine object can provide the argc and argv parameters
 * for use with the Glib::OptionContext command-line parsing API, with the
 * get_arguments() method.
 *
 * The exit status of the originally-invoked process may be set and messages
 * can be printed to stdout or stderr of that process. The lifecycle of the
 * originally-invoked process is tied to the lifecycle of this object (ie: the
 * process exits when the last reference is dropped).
 *
 * The main use for ApplicationCommandline (and the "command-line" signal) is
 * 'Emacs server' like use cases: You can set the EDITOR environment variable
 * to have e.g. git use your favourite editor to edit commit messages, and if
 * you already have an instance of the editor running, the editing will happen
 * in the running instance, instead of opening a new one. An important aspect
 * of this use case is that the process that gets started by git does not
 * return until the editing is done.
 * @newin{2,32}
 */

class ApplicationCommandLine : public Glib::Object
{
  
#ifndef DOXYGEN_SHOULD_SKIP_THIS

public:
  typedef ApplicationCommandLine CppObjectType;
  typedef ApplicationCommandLine_Class CppClassType;
  typedef GApplicationCommandLine BaseObjectType;
  typedef GApplicationCommandLineClass BaseClassType;

private:  friend class ApplicationCommandLine_Class;
  static CppClassType applicationcommandline_class_;

private:
  // noncopyable
  ApplicationCommandLine(const ApplicationCommandLine&);
  ApplicationCommandLine& operator=(const ApplicationCommandLine&);

protected:
  explicit ApplicationCommandLine(const Glib::ConstructParams& construct_params);
  explicit ApplicationCommandLine(GApplicationCommandLine* castitem);

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

public:
  virtual ~ApplicationCommandLine();

#ifndef DOXYGEN_SHOULD_SKIP_THIS
  static GType get_type()      G_GNUC_CONST;


  static GType get_base_type() G_GNUC_CONST;
#endif

  ///Provides access to the underlying C GObject.
  GApplicationCommandLine*       gobj()       { return reinterpret_cast<GApplicationCommandLine*>(gobject_); }

  ///Provides access to the underlying C GObject.
  const GApplicationCommandLine* gobj() const { return reinterpret_cast<GApplicationCommandLine*>(gobject_); }

  ///Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.
  GApplicationCommandLine* gobj_copy();

private:


protected:
  ApplicationCommandLine();

public:

  
  /** Gets the list of arguments that was passed on the command line.
   * 
   * The strings in the array may contain non-utf8 data.
   * 
   * The return value is <tt>0</tt>-terminated and should be freed using
   * Glib::strfreev().
   * 
   * @newin{2,28}
   * @param argc The length of the arguments array, or <tt>0</tt>.
   * @return The string array
   * containing the arguments (the argv).
   */
  char** get_arguments(int& argc) const;
  
  //We use std::string instead of ustring because the C documentation says that it may be non-UTF-8 data:
  
  /** Gets the working directory of the command line invocation.
   * The string may contain non-utf8 data.
   * 
   * It is possible that the remote application did not send a working
   * directory, so this may be <tt>0</tt>.
   * 
   * The return value should not be modified or freed and is valid for as
   * long as @a cmdline exists.
   * 
   * @newin{2,28}
   * @return The current directory, or <tt>0</tt>.
   */
  std::string get_cwd() const;

  //We use std::string instead of ustring because the C documentation says that it may be non-UTF-8 data:
 

  /** Gets the contents of the 'environ' variable of the command line
   * invocation, as would be returned by Glib::get_environ(), ie as a
   * <tt>0</tt>-terminated list of strings in the form 'NAME=VALUE'.
   * The strings may contain non-utf8 data.
   * 
   * The remote application usually does not send an environment.  Use
   * APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
   * set it is possible that the environment is still not available (due
   * to invocation messages from other applications).
   * 
   * The return value should not be modified or freed and is valid for as
   * long as @a cmdline exists.
   * 
   * See g_application_command_line_getenv() if you are only interested
   * in the value of a single environment variable.
   * 
   * @newin{2,28}
   * @return The environment
   * strings, or <tt>0</tt> if they were not sent.
   */
  std::vector<std::string> get_environ() const;
  
  //We use std::string instead of ustring because the C documentation says that it may be non-UTF-8 data:
  
  /** Gets the value of a particular environment variable of the command
   * line invocation, as would be returned by Glib::getenv().  The strings may
   * contain non-utf8 data.
   * 
   * The remote application usually does not send an environment.  Use
   * APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
   * set it is possible that the environment is still not available (due
   * to invocation messages from other applications).
   * 
   * The return value should not be modified or freed and is valid for as
   * long as @a cmdline exists.
   * 
   * @newin{2,28}
   * @param name The environment variable to get.
   * @return The value of the variable, or <tt>0</tt> if unset or unsent.
   */
  std::string getenv(const Glib::ustring& name) const;
  
  
  /** Determines if @a cmdline represents a remote invocation.
   * 
   * @newin{2,28}
   * @return <tt>true</tt> if the invocation was remote.
   */
  bool is_remote() const;

 
  /** Gets the platform data associated with the invocation of @a cmdline.
   * 
   * This is a Variant dictionary containing information about the
   * context in which the invocation occurred.  It typically contains
   * information like the current working directory and the startup
   * notification ID.
   * 
   * For local invocation, it will be <tt>0</tt>.
   * 
   * @newin{2,28}
   * @return The platform data, or <tt>0</tt>.
   */
  Glib::Variant< std::map<Glib::ustring, Glib::VariantBase> > get_platform_data() const;
 
  
  /** Sets the exit status that will be used when the invoking process
   * exits.
   * 
   * The return value of the Application::signal_command_line() signal is
   * passed to this function when the handler returns.  This is the usual
   * way of setting the exit status.
   * 
   * In the event that you want the remote invocation to continue running
   * and want to decide on the exit status in the future, you can use this
   * call.  For the case of a remote invocation, the remote process will
   * typically exit when the last reference is dropped on @a cmdline.  The
   * exit status of the remote process will be equal to the last value
   * that was set with this function.
   * 
   * In the case that the commandline invocation is local, the situation
   * is slightly more complicated.  If the commandline invocation results
   * in the mainloop running (ie: because the use-count of the application
   * increased to a non-zero value) then the application is considered to
   * have been 'successful' in a certain sense, and the exit status is
   * always zero.  If the application use count is zero, though, the exit
   * status of the local ApplicationCommandLine is used.
   * 
   * @newin{2,28}
   * @param exit_status The exit status.
   */
  void set_exit_status(int exit_status);
  
  /** Gets the exit status of @a cmdline.  See
   * g_application_command_line_set_exit_status() for more information.
   * 
   * @newin{2,28}
   * @return The exit status.
   */
  int get_exit_status() const;
  
  /** Formats a message and prints it using the stdout print handler in the invoking process.
   * If this is a local invocation then this is exactly equivalent to g_print().
   *  If this is remote then this is equivalent to calling g_print() in the invoking process.
   *
   * @param message The text to print.
   */
  void print(const Glib::ustring& message);
  
  
  /** Formats a message and prints it using the stderr print handler in the invoking process.
   * If this is a local invocation then this is exactly equivalent to g_printerr().
   *  If this is remote then this is equivalent to calling g_printerr() in the invoking process.
   *
   * @param message The text to print.
   */
  void printerr(const Glib::ustring& message);
  

public:

public:
  //C++ methods used to invoke GTK+ virtual functions:

protected:
  //GTK+ Virtual Functions (override these to change behaviour):

  //Default Signal Handlers::


};


} // namespace Gio


namespace Glib
{
  /** A Glib::wrap() method for this object.
   * 
   * @param object The C instance.
   * @param take_copy False if the result should take ownership of the C instance. True if it should take a new copy or ref.
   * @result A C++ instance that wraps this C instance.
   *
   * @relates Gio::ApplicationCommandLine
   */
  Glib::RefPtr<Gio::ApplicationCommandLine> wrap(GApplicationCommandLine* object, bool take_copy = false);
}


#endif /* _GIOMM_APPLICATIONCOMMANDLINE_H */

