// -*- c++ -*-
// Generated by gtkmmproc -- DO NOT MODIFY!
#ifndef _GIOMM_ACTIONMAP_H
#define _GIOMM_ACTIONMAP_H


#include <glibmm/ustring.h>
#include <sigc++/sigc++.h>

// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* Copyright (C) 2012 The giomm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <glibmm/interface.h>


#ifndef DOXYGEN_SHOULD_SKIP_THIS
typedef struct _GActionMapInterface GActionMapInterface;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

#ifndef DOXYGEN_SHOULD_SKIP_THIS
typedef struct _GActionMap GActionMap;
typedef struct _GActionMapClass GActionMapClass;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gio
{ class ActionMap_Class; } // namespace Gio
namespace Gio
{

class Action;

/** ActionMap - Interface for action containers.
 * The ActionMap interface is implemented by ActionGroup implementations that
 * operate by containing a number of named Action instances, such as
 * SimpleActionGroup.
 *
 * One useful application of this interface is to map the names of actions from
 * various action groups to unique, prefixed names (e.g. by prepending "app."
 * or "win."). This is the motivation for the 'Map' part of the interface name.
 * @newin{2,32}
 */

class ActionMap : public Glib::Interface
{
  
#ifndef DOXYGEN_SHOULD_SKIP_THIS

public:
  typedef ActionMap CppObjectType;
  typedef ActionMap_Class CppClassType;
  typedef GActionMap BaseObjectType;
  typedef GActionMapInterface BaseClassType;

private:
  friend class ActionMap_Class;
  static CppClassType actionmap_class_;

  // noncopyable
  ActionMap(const ActionMap&);
  ActionMap& operator=(const ActionMap&);

#endif /* DOXYGEN_SHOULD_SKIP_THIS */
protected:
  /**
   * You should derive from this class to use it.
   */
  ActionMap();
  
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  /** Called by constructors of derived classes. Provide the result of 
   * the Class init() function to ensure that it is properly 
   * initialized.
   * 
   * @param interface_class The Class object for the derived type.
   */
  explicit ActionMap(const Glib::Interface_Class& interface_class);

public:
  // This is public so that C++ wrapper instances can be
  // created for C instances of unwrapped types.
  // For instance, if an unexpected C type implements the C interface. 
  explicit ActionMap(GActionMap* castitem);

protected:
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

public:
  virtual ~ActionMap();

  static void add_interface(GType gtype_implementer);

#ifndef DOXYGEN_SHOULD_SKIP_THIS
  static GType get_type()      G_GNUC_CONST;
  static GType get_base_type() G_GNUC_CONST;
#endif

  ///Provides access to the underlying C GObject.
  GActionMap*       gobj()       { return reinterpret_cast<GActionMap*>(gobject_); }

  ///Provides access to the underlying C GObject.
  const GActionMap* gobj() const { return reinterpret_cast<GActionMap*>(gobject_); }

private:


public:
  
  /** Looks up the action with the name @a action_name in @a action_map.
   * 
   * If no such action exists, returns <tt>0</tt>.
   * 
   * @newin{2,32}
   * @param action_name The name of an action.
   * @return A Action, or <tt>0</tt>.
   */
  Glib::RefPtr<Action> lookup_action(const Glib::ustring& action_name);
  
  /** Looks up the action with the name @a action_name in @a action_map.
   * 
   * If no such action exists, returns <tt>0</tt>.
   * 
   * @newin{2,32}
   * @param action_name The name of an action.
   * @return A Action, or <tt>0</tt>.
   */
  Glib::RefPtr<const Action> lookup_action(const Glib::ustring& action_name) const;

  //TODO: _WRAP_METHOD(void add_action_entries(const GActionEntry* entries, int n_entries, gpointer user_data), g_action_map_add_action_entries)

  
  /** Adds an action to the @a action_map.
   * 
   * If the action map already contains an action with the same name
   * as @a action then the old action is dropped from the action map.
   * 
   * The action map takes its own reference on @a action.
   * 
   * @newin{2,32}
   * @param action A Action.
   */
  void add_action(const Glib::RefPtr<Action>& action);
  
  /** Removes the named action from the action map.
   * 
   * If no action of this name is in the map then nothing happens.
   * 
   * @newin{2,32}
   * @param action_name The name of the action.
   */
  void remove_action(const Glib::ustring& action_name);

 
    virtual Glib::RefPtr<Action> lookup_action_vfunc(const Glib::ustring& name) const;


    virtual void add_action_vfunc(Glib::RefPtr<Action> action) const;

    virtual void remove_action_vfunc(const Glib::ustring& name);


public:

public:
  //C++ methods used to invoke GTK+ virtual functions:

protected:
  //GTK+ Virtual Functions (override these to change behaviour):

  //Default Signal Handlers::


};

} // namespace Gio


namespace Glib
{
  /** A Glib::wrap() method for this object.
   * 
   * @param object The C instance.
   * @param take_copy False if the result should take ownership of the C instance. True if it should take a new copy or ref.
   * @result A C++ instance that wraps this C instance.
   *
   * @relates Gio::ActionMap
   */
  Glib::RefPtr<Gio::ActionMap> wrap(GActionMap* object, bool take_copy = false);

} // namespace Glib


#endif /* _GIOMM_ACTIONMAP_H */

