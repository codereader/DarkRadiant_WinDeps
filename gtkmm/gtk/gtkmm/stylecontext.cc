// Generated by gtkmmproc -- DO NOT MODIFY!


#include <glibmm.h>

#include <gtkmm/stylecontext.h>
#include <gtkmm/private/stylecontext_p.h>


// -*- c++ -*-
/* $Id: style.ccg,v 1.5 2006/11/23 14:47:48 murrayc Exp $ */

/* Copyright 1998-2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include <gtkmm/widget.h>
#include <gtk/gtk.h>


namespace Gtk
{


Gdk::RGBA StyleContext::get_color(StateFlags state) const
{
  GdkRGBA crgba;
  gtk_style_context_get_color(const_cast<GtkStyleContext*>(gobj()), ((GtkStateFlags)(state)), &crgba);
  return Gdk::RGBA(&crgba, true); 
}

Gdk::RGBA StyleContext::get_background_color(StateFlags state) const
{
  GdkRGBA crgba;
  gtk_style_context_get_background_color(const_cast<GtkStyleContext*>(gobj()), ((GtkStateFlags)(state)), &crgba);
  return Gdk::RGBA(&crgba, true); 
}

Gdk::RGBA StyleContext::get_border_color(StateFlags state) const
{
  GdkRGBA crgba;
  gtk_style_context_get_border_color(const_cast<GtkStyleContext*>(gobj()), ((GtkStateFlags)(state)), &crgba);
  return Gdk::RGBA(&crgba, true); 
}

Border StyleContext::get_border(StateFlags state) const
{
  GtkBorder cborder;
  gtk_style_context_get_border(const_cast<GtkStyleContext*>(gobj()), ((GtkStateFlags)(state)), &cborder);
  return Border(&cborder, true); 
}

Border StyleContext::get_padding(StateFlags state) const
{
  GtkBorder cborder;
  gtk_style_context_get_padding(const_cast<GtkStyleContext*>(gobj()), ((GtkStateFlags)(state)), &cborder);
  return Border(&cborder, true); 
}

Border StyleContext::get_margin(StateFlags state) const
{
  GtkBorder cborder;
  gtk_style_context_get_margin(const_cast<GtkStyleContext*>(gobj()), ((GtkStateFlags)(state)), &cborder);
  return Border(&cborder, true); 
}

void StyleContext::unset_parent()
{
  gtk_style_context_set_parent(gobj(), 0);
}


} // namespace Gtk

namespace
{


static const Glib::SignalProxyInfo StyleContext_signal_changed_info =
{
  "changed",
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback,
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback
};


} // anonymous namespace


namespace Glib
{

Glib::RefPtr<Gtk::StyleContext> wrap(GtkStyleContext* object, bool take_copy)
{
  return Glib::RefPtr<Gtk::StyleContext>( dynamic_cast<Gtk::StyleContext*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& StyleContext_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &StyleContext_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gtk_style_context_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:

  }

  return *this;
}


void StyleContext_Class::class_init_function(void* g_class, void* class_data)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


  klass->changed = &changed_callback;
}


void StyleContext_Class::changed_callback(GtkStyleContext* self)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->on_changed();
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }

  BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

  // Call the original underlying C function:
  if(base && base->changed)
    (*base->changed)(self);
}


Glib::ObjectBase* StyleContext_Class::wrap_new(GObject* object)
{
  return new StyleContext((GtkStyleContext*)object);
}


/* The implementation: */

GtkStyleContext* StyleContext::gobj_copy()
{
  reference();
  return gobj();
}

StyleContext::StyleContext(const Glib::ConstructParams& construct_params)
:
  Glib::Object(construct_params)
{

}

StyleContext::StyleContext(GtkStyleContext* castitem)
:
  Glib::Object((GObject*)(castitem))
{}


StyleContext::~StyleContext()
{}


StyleContext::CppClassType StyleContext::stylecontext_class_; // initialize static member

GType StyleContext::get_type()
{
  return stylecontext_class_.init().get_type();
}


GType StyleContext::get_base_type()
{
  return gtk_style_context_get_type();
}


StyleContext::StyleContext()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(0),
  Glib::Object(Glib::ConstructParams(stylecontext_class_.init()))
{
  

}

Glib::RefPtr<StyleContext> StyleContext::create()
{
  return Glib::RefPtr<StyleContext>( new StyleContext() );
}

void StyleContext::add_provider_for_screen(const Glib::RefPtr<Gdk::Screen>& screen, const Glib::RefPtr<StyleProvider>& provider, guint priority)
{
gtk_style_context_add_provider_for_screen(Glib::unwrap(screen), Glib::unwrap(provider), priority);
}


void StyleContext::remove_provider_for_screen(const Glib::RefPtr<Gdk::Screen>& screen, const Glib::RefPtr<StyleProvider>& provider)
{
gtk_style_context_remove_provider_for_screen(Glib::unwrap(screen), Glib::unwrap(provider));
}


void StyleContext::add_provider(const Glib::RefPtr<StyleProvider>& provider, guint priority)
{
  gtk_style_context_add_provider(gobj(), Glib::unwrap(provider), priority); 
}

void StyleContext::remove_provider(const Glib::RefPtr<StyleProvider>& provider)
{
  gtk_style_context_remove_provider(gobj(), Glib::unwrap(provider)); 
}

void StyleContext::context_save()
{
  gtk_style_context_save(gobj()); 
}

void StyleContext::context_restore()
{
  gtk_style_context_restore(gobj()); 
}

void StyleContext::set_state(StateFlags flags)
{
  gtk_style_context_set_state(gobj(), ((GtkStateFlags)(flags))); 
}

StateFlags StyleContext::get_state() const
{
  return ((StateFlags)(gtk_style_context_get_state(const_cast<GtkStyleContext*>(gobj()))));
}

bool StyleContext::state_is_running(StateType state, gdouble* progress)
{
  return gtk_style_context_state_is_running(gobj(), ((GtkStateType)(state)), progress);
}

void StyleContext::set_path(const WidgetPath& path)
{
  gtk_style_context_set_path(gobj(), const_cast<WidgetPath&>(path).gobj()); 
}

WidgetPath StyleContext::get_path() const
{
  return WidgetPath(const_cast<GtkWidgetPath*>(gtk_style_context_get_path(const_cast<GtkStyleContext*>(gobj()))), true);
}

void StyleContext::set_parent(const Glib::RefPtr<StyleContext>& parent)
{
  gtk_style_context_set_parent(gobj(), Glib::unwrap(parent)); 
}

Glib::RefPtr<StyleContext> StyleContext::get_parent()
{

  Glib::RefPtr<StyleContext> retvalue = Glib::wrap(gtk_style_context_get_parent(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;

}

Glib::RefPtr<const StyleContext> StyleContext::get_parent() const
{
  return const_cast<StyleContext*>(this)->get_parent();
}

std::vector<Glib::ustring> StyleContext::list_classes() const
{
  return Glib::ListHandler<Glib::ustring>::list_to_vector(gtk_style_context_list_classes(const_cast<GtkStyleContext*>(gobj())), Glib::OWNERSHIP_SHALLOW);
}

void StyleContext::add_class(const Glib::ustring& class_name)
{
  gtk_style_context_add_class(gobj(), class_name.c_str()); 
}

void StyleContext::remove_class(const Glib::ustring& class_name)
{
  gtk_style_context_remove_class(gobj(), class_name.c_str()); 
}

bool StyleContext::has_class(const Glib::ustring& class_name)
{
  return gtk_style_context_has_class(gobj(), class_name.c_str());
}

GList* StyleContext::list_regions()
{
  return gtk_style_context_list_regions(gobj());
}

void StyleContext::add_region(const Glib::ustring& region_name, RegionFlags flags)
{
  gtk_style_context_add_region(gobj(), region_name.c_str(), ((GtkRegionFlags)(flags))); 
}

void StyleContext::remove_region(const Glib::ustring& region_name)
{
  gtk_style_context_remove_region(gobj(), region_name.c_str()); 
}

bool StyleContext::has_region(const Glib::ustring& region_name, RegionFlags& flags_return)
{
  return gtk_style_context_has_region(gobj(), region_name.c_str(), ((GtkRegionFlags*) &(flags_return)));
}

Glib::RefPtr<IconSet> StyleContext::lookup_icon_set(const Glib::ustring& stock_id)
{

  Glib::RefPtr<IconSet> retvalue = Glib::wrap(gtk_style_context_lookup_icon_set(gobj(), stock_id.c_str()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;

}

void StyleContext::set_screen(const Glib::RefPtr<Gdk::Screen>& screen)
{
  gtk_style_context_set_screen(gobj(), Glib::unwrap(screen)); 
}

Glib::RefPtr<Gdk::Screen> StyleContext::get_screen()
{

  Glib::RefPtr<Gdk::Screen> retvalue = Glib::wrap(gtk_style_context_get_screen(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;

}

Glib::RefPtr<const Gdk::Screen> StyleContext::get_screen() const
{
  return const_cast<StyleContext*>(this)->get_screen();
}

void StyleContext::set_direction(TextDirection direction)
{
  gtk_style_context_set_direction(gobj(), ((GtkTextDirection)(direction))); 
}

TextDirection StyleContext::get_direction() const
{
  return ((TextDirection)(gtk_style_context_get_direction(const_cast<GtkStyleContext*>(gobj()))));
}

void StyleContext::set_junction_sides(JunctionSides sides)
{
  gtk_style_context_set_junction_sides(gobj(), ((GtkJunctionSides)(sides))); 
}

JunctionSides StyleContext::get_junction_sides() const
{
  return ((JunctionSides)(gtk_style_context_get_junction_sides(const_cast<GtkStyleContext*>(gobj()))));
}

bool StyleContext::lookup_color(const Glib::ustring& color_name, Gdk::RGBA& color)
{
  return gtk_style_context_lookup_color(gobj(), color_name.c_str(), (color).gobj());
}

void StyleContext::notify_state_change(const Glib::RefPtr<Gdk::Window>& window, gpointer region_id, StateType state, bool state_value)
{
  gtk_style_context_notify_state_change(gobj(), Glib::unwrap(window), region_id, ((GtkStateType)(state)), static_cast<int>(state_value)); 
}

void StyleContext::cancel_animations(gpointer region_id)
{
  gtk_style_context_cancel_animations(gobj(), region_id); 
}

void StyleContext::scroll_animations(const Glib::RefPtr<Gdk::Window>& window, int dx, int dy)
{
  gtk_style_context_scroll_animations(gobj(), Glib::unwrap(window), dx, dy); 
}

void StyleContext::push_animatable_region(gpointer region_id)
{
  gtk_style_context_push_animatable_region(gobj(), region_id); 
}

void StyleContext::pop_animatable_region()
{
  gtk_style_context_pop_animatable_region(gobj()); 
}

Pango::FontDescription StyleContext::get_font(StateFlags state) const
{
  return Glib::wrap(const_cast<PangoFontDescription*>(gtk_style_context_get_font(const_cast<GtkStyleContext*>(gobj()), ((GtkStateFlags)(state)))), true);
}

void StyleContext::invalidate()
{
  gtk_style_context_invalidate(gobj()); 
}

void StyleContext::set_background(const Glib::RefPtr<Gdk::Window>& window)
{
  gtk_style_context_set_background(gobj(), Glib::unwrap(window)); 
}

void StyleContext::render_check(const ::Cairo::RefPtr< ::Cairo::Context>& cr, double x, double y, double width, double height)
{
  gtk_render_check(gobj(), (cr)->cobj(), x, y, width, height); 
}

void StyleContext::render_option(const ::Cairo::RefPtr< ::Cairo::Context>& cr, double x, double y, double width, double height)
{
  gtk_render_option(gobj(), (cr)->cobj(), x, y, width, height); 
}

void StyleContext::render_arrow(const ::Cairo::RefPtr< ::Cairo::Context>& cr, double angle, double x, double y, double size)
{
  gtk_render_arrow(gobj(), (cr)->cobj(), angle, x, y, size); 
}

void StyleContext::render_background(const ::Cairo::RefPtr< ::Cairo::Context>& cr, double x, double y, double width, double height)
{
  gtk_render_background(gobj(), (cr)->cobj(), x, y, width, height); 
}

void StyleContext::render_frame(const ::Cairo::RefPtr< ::Cairo::Context>& cr, double x, double y, double width, double height)
{
  gtk_render_frame(gobj(), (cr)->cobj(), x, y, width, height); 
}

void StyleContext::render_expander(const ::Cairo::RefPtr< ::Cairo::Context>& cr, double x, double y, double width, double height)
{
  gtk_render_expander(gobj(), (cr)->cobj(), x, y, width, height); 
}

void StyleContext::render_focus(const ::Cairo::RefPtr< ::Cairo::Context>& cr, double x, double y, double width, double height)
{
  gtk_render_focus(gobj(), (cr)->cobj(), x, y, width, height); 
}

void StyleContext::render_layout(const ::Cairo::RefPtr< ::Cairo::Context>& cr, double x, double y, PangoLayout * layout)
{
  gtk_render_layout(gobj(), (cr)->cobj(), x, y, layout); 
}

void StyleContext::render_line(const ::Cairo::RefPtr< ::Cairo::Context>& cr, double x0, double y0, double x1, double y1)
{
  gtk_render_line(gobj(), (cr)->cobj(), x0, y0, x1, y1); 
}

void StyleContext::render_slider(const ::Cairo::RefPtr< ::Cairo::Context>& cr, double x, double y, double width, double height, Orientation orientation)
{
  gtk_render_slider(gobj(), (cr)->cobj(), x, y, width, height, ((GtkOrientation)(orientation))); 
}

void StyleContext::render_frame_gap(const ::Cairo::RefPtr< ::Cairo::Context>& cr, double x, double y, double width, double height, PositionType gap_side, double xy0_gap, double xy1_gap)
{
  gtk_render_frame_gap(gobj(), (cr)->cobj(), x, y, width, height, ((GtkPositionType)(gap_side)), xy0_gap, xy1_gap); 
}

void StyleContext::render_extension(const ::Cairo::RefPtr< ::Cairo::Context>& cr, double x, double y, double width, double height, PositionType gap_side)
{
  gtk_render_extension(gobj(), (cr)->cobj(), x, y, width, height, ((GtkPositionType)(gap_side))); 
}

void StyleContext::render_handle(const ::Cairo::RefPtr< ::Cairo::Context>& cr, double x, double y, double width, double height)
{
  gtk_render_handle(gobj(), (cr)->cobj(), x, y, width, height); 
}

void StyleContext::render_activity(const ::Cairo::RefPtr< ::Cairo::Context>& cr, double x, double y, double width, double height)
{
  gtk_render_activity(gobj(), (cr)->cobj(), x, y, width, height); 
}

Glib::RefPtr<Gdk::Pixbuf> StyleContext::render_icon_pixbuf(const IconSource& source, IconSize size)
{
  return Glib::wrap(gtk_render_icon_pixbuf(gobj(), (source).gobj(), static_cast<GtkIconSize>(int(size))));
}


Glib::SignalProxy0< void > StyleContext::signal_changed()
{
  return Glib::SignalProxy0< void >(this, &StyleContext_signal_changed_info);
}


#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy< Glib::RefPtr<Gdk::Screen> > StyleContext::property_screen() 
{
  return Glib::PropertyProxy< Glib::RefPtr<Gdk::Screen> >(this, "screen");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Screen> > StyleContext::property_screen() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Screen> >(this, "screen");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy< TextDirection > StyleContext::property_direction() 
{
  return Glib::PropertyProxy< TextDirection >(this, "direction");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly< TextDirection > StyleContext::property_direction() const
{
  return Glib::PropertyProxy_ReadOnly< TextDirection >(this, "direction");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy< Glib::RefPtr<StyleContext> > StyleContext::property_parent() 
{
  return Glib::PropertyProxy< Glib::RefPtr<StyleContext> >(this, "parent");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly< Glib::RefPtr<StyleContext> > StyleContext::property_parent() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<StyleContext> >(this, "parent");
}
#endif //GLIBMM_PROPERTIES_ENABLED


void Gtk::StyleContext::on_changed()
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->changed)
    (*base->changed)(gobj());
}


} // namespace Gtk


