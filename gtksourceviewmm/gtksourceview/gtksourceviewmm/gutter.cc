// Generated by gtkmmproc -- DO NOT MODIFY!


#include <gtksourceviewmm/gutter.h>
#include <gtksourceviewmm/private/gutter_p.h>

/* gutter.cc
 *
 * Copyright (C) 2009, 2010, 2011 Krzesimir Nowak
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gtksourceview/gtksourcegutter.h>


namespace
{
} // anonymous namespace


namespace Glib
{

Glib::RefPtr<Gsv::Gutter> wrap(GtkSourceGutter* object, bool take_copy)
{
  return Glib::RefPtr<Gsv::Gutter>( dynamic_cast<Gsv::Gutter*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gsv
{


/* The *_Class implementation: */

const Glib::Class& Gutter_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &Gutter_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gtk_source_gutter_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:

  }

  return *this;
}


void Gutter_Class::class_init_function(void* g_class, void* class_data)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* Gutter_Class::wrap_new(GObject* object)
{
  return new Gutter((GtkSourceGutter*)object);
}


/* The implementation: */

GtkSourceGutter* Gutter::gobj_copy()
{
  reference();
  return gobj();
}

Gutter::Gutter(const Glib::ConstructParams& construct_params)
:
  Glib::Object(construct_params)
{

}

Gutter::Gutter(GtkSourceGutter* castitem)
:
  Glib::Object((GObject*)(castitem))
{}


Gutter::~Gutter()
{}


Gutter::CppClassType Gutter::gutter_class_; // initialize static member

GType Gutter::get_type()
{
  return gutter_class_.init().get_type();
}


GType Gutter::get_base_type()
{
  return gtk_source_gutter_get_type();
}


Glib::RefPtr<Gdk::Window> Gutter::get_window()
{

  Glib::RefPtr<Gdk::Window> retvalue = Glib::wrap(gtk_source_gutter_get_window(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;

}

Glib::RefPtr<const Gdk::Window> Gutter::get_window() const
{
  return const_cast<Gutter*>(this)->get_window();
}

void Gutter::insert(GutterRenderer* renderer, int position)
{
gtk_source_gutter_insert(gobj(), (renderer)->gobj(), position); 
}

void Gutter::remove(GutterRenderer* renderer)
{
gtk_source_gutter_remove(gobj(), (renderer)->gobj()); 
}

void Gutter::reorder(GutterRenderer* renderer, int position)
{
gtk_source_gutter_reorder(gobj(), (renderer)->gobj(), position); 
}

void Gutter::queue_draw()
{
gtk_source_gutter_queue_draw(gobj()); 
}

void Gutter::set_padding(int xpad, int ypad)
{
gtk_source_gutter_set_padding(gobj(), xpad, ypad); 
}

void Gutter::get_padding(int& xpad, int& ypad) const
{
gtk_source_gutter_get_padding(const_cast<GtkSourceGutter*>(gobj()), &(xpad), &(ypad)); 
}

GutterRenderer* Gutter::get_renderer_at_pos(int x, int y)
{

  GutterRenderer* retvalue = Glib::wrap(gtk_source_gutter_get_renderer_at_pos(gobj(), x, y));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;

}

const GutterRenderer* Gutter::get_renderer_at_pos(int x, int y) const
{
  return const_cast<Gutter*>(this)->get_renderer_at_pos(x, y);
}


#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<View*> Gutter::property_view() const
{
  return Glib::PropertyProxy_ReadOnly<View*>(this, "view");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<Gtk::TextWindowType> Gutter::property_window_type() const
{
  return Glib::PropertyProxy_ReadOnly<Gtk::TextWindowType>(this, "window-type");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<int> Gutter::property_xpad() 
{
  return Glib::PropertyProxy<int>(this, "xpad");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<int> Gutter::property_xpad() const
{
  return Glib::PropertyProxy_ReadOnly<int>(this, "xpad");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<int> Gutter::property_ypad() 
{
  return Glib::PropertyProxy<int>(this, "ypad");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<int> Gutter::property_ypad() const
{
  return Glib::PropertyProxy_ReadOnly<int>(this, "ypad");
}
#endif //GLIBMM_PROPERTIES_ENABLED


} // namespace Gsv


