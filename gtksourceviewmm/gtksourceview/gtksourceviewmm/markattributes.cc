// Generated by gtkmmproc -- DO NOT MODIFY!


#include <gtksourceviewmm/markattributes.h>
#include <gtksourceviewmm/private/markattributes_p.h>

/* markattributes.cc
 *
 * Copyright (C) 2010, 2011 Krzesimir Nowak
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gtksourceview/gtksourcemarkattributes.h>

#include <giomm/icon.h>
#include <gdkmm/pixbuf.h>
#include <gdkmm/rgba.h>
#include <gtkmm/widget.h>
#include <gtksourceviewmm/mark.h>

namespace Gsv
{

bool MarkAttributes::is_background_set() const
{
  return gtk_source_mark_attributes_get_background(const_cast<MarkAttributes*>(this)->gobj(), 0);
}

} // namespace Gsv

namespace
{


static const gchar* MarkAttributes_signal_query_tooltip_text_callback(GtkSourceMarkAttributes* self, GtkSourceMark* p0,void* data)
{
  using namespace Gsv;
  typedef sigc::slot< Glib::ustring,const Glib::RefPtr<Mark>& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return ((*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
)).c_str();
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }

  typedef const gchar* RType;
  return RType();
}

static const gchar* MarkAttributes_signal_query_tooltip_text_notify_callback(GtkSourceMarkAttributes* self, GtkSourceMark* p0, void* data)
{
  using namespace Gsv;
  typedef sigc::slot< void,const Glib::RefPtr<Mark>& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }

  typedef const gchar* RType;
  return RType();
}

static const Glib::SignalProxyInfo MarkAttributes_signal_query_tooltip_text_info =
{
  "query-tooltip-text",
  (GCallback) &MarkAttributes_signal_query_tooltip_text_callback,
  (GCallback) &MarkAttributes_signal_query_tooltip_text_notify_callback
};


static const gchar* MarkAttributes_signal_query_tooltip_markup_callback(GtkSourceMarkAttributes* self, GtkSourceMark* p0,void* data)
{
  using namespace Gsv;
  typedef sigc::slot< Glib::ustring,const Glib::RefPtr<Mark>& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return ((*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
)).c_str();
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }

  typedef const gchar* RType;
  return RType();
}

static const gchar* MarkAttributes_signal_query_tooltip_markup_notify_callback(GtkSourceMarkAttributes* self, GtkSourceMark* p0, void* data)
{
  using namespace Gsv;
  typedef sigc::slot< void,const Glib::RefPtr<Mark>& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }

  typedef const gchar* RType;
  return RType();
}

static const Glib::SignalProxyInfo MarkAttributes_signal_query_tooltip_markup_info =
{
  "query-tooltip-markup",
  (GCallback) &MarkAttributes_signal_query_tooltip_markup_callback,
  (GCallback) &MarkAttributes_signal_query_tooltip_markup_notify_callback
};


} // anonymous namespace


namespace Glib
{

Glib::RefPtr<Gsv::MarkAttributes> wrap(GtkSourceMarkAttributes* object, bool take_copy)
{
  return Glib::RefPtr<Gsv::MarkAttributes>( dynamic_cast<Gsv::MarkAttributes*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gsv
{


/* The *_Class implementation: */

const Glib::Class& MarkAttributes_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &MarkAttributes_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gtk_source_mark_attributes_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:

  }

  return *this;
}


void MarkAttributes_Class::class_init_function(void* g_class, void* class_data)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* MarkAttributes_Class::wrap_new(GObject* object)
{
  return new MarkAttributes((GtkSourceMarkAttributes*)object);
}


/* The implementation: */

GtkSourceMarkAttributes* MarkAttributes::gobj_copy()
{
  reference();
  return gobj();
}

MarkAttributes::MarkAttributes(const Glib::ConstructParams& construct_params)
:
  Glib::Object(construct_params)
{

}

MarkAttributes::MarkAttributes(GtkSourceMarkAttributes* castitem)
:
  Glib::Object((GObject*)(castitem))
{}


MarkAttributes::~MarkAttributes()
{}


MarkAttributes::CppClassType MarkAttributes::markattributes_class_; // initialize static member

GType MarkAttributes::get_type()
{
  return markattributes_class_.init().get_type();
}


GType MarkAttributes::get_base_type()
{
  return gtk_source_mark_attributes_get_type();
}


MarkAttributes::MarkAttributes()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(0),
  Glib::Object(Glib::ConstructParams(markattributes_class_.init()))
{
  

}

Glib::RefPtr<MarkAttributes> MarkAttributes::create()
{
  return Glib::RefPtr<MarkAttributes>( new MarkAttributes() );
}

bool MarkAttributes::get_background(Gdk::RGBA& rgba) const
{
  return gtk_source_mark_attributes_get_background(const_cast<GtkSourceMarkAttributes*>(gobj()), (rgba).gobj());
}

void MarkAttributes::set_background(const Gdk::RGBA& rgba)
{
gtk_source_mark_attributes_set_background(gobj(), (rgba).gobj()); 
}

std::string MarkAttributes::get_stock_id() const
{
  return Glib::convert_const_gchar_ptr_to_stdstring(gtk_source_mark_attributes_get_stock_id(const_cast<GtkSourceMarkAttributes*>(gobj())));
}

void MarkAttributes::set_stock_id(const std::string& stock_id)
{
gtk_source_mark_attributes_set_stock_id(gobj(), stock_id.c_str()); 
}

void MarkAttributes::set_icon_name(const std::string& icon_name)
{
gtk_source_mark_attributes_set_icon_name(gobj(), icon_name.c_str()); 
}

std::string MarkAttributes::get_icon_name() const
{
  return Glib::convert_const_gchar_ptr_to_stdstring(gtk_source_mark_attributes_get_icon_name(const_cast<GtkSourceMarkAttributes*>(gobj())));
}

Glib::RefPtr<Gio::Icon> MarkAttributes::get_icon()
{

  Glib::RefPtr<Gio::Icon> retvalue = Glib::wrap(gtk_source_mark_attributes_get_gicon(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;

}

Glib::RefPtr<const Gio::Icon> MarkAttributes::get_icon() const
{
  return const_cast<MarkAttributes*>(this)->get_icon();
}

void MarkAttributes::set_icon(const Glib::RefPtr<Gio::Icon>& icon)
{
gtk_source_mark_attributes_set_gicon(gobj(), Glib::unwrap(icon)); 
}

Glib::RefPtr<const Gdk::Pixbuf> MarkAttributes::get_pixbuf() const
{

  Glib::RefPtr<const Gdk::Pixbuf> retvalue = Glib::wrap(const_cast<GdkPixbuf*>(gtk_source_mark_attributes_get_pixbuf(const_cast<GtkSourceMarkAttributes*>(gobj()))));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;

}

void MarkAttributes::set_pixbuf(const Glib::RefPtr<const Gdk::Pixbuf>& pixbuf)
{
gtk_source_mark_attributes_set_pixbuf(gobj(), Glib::unwrap(pixbuf)); 
}

Glib::RefPtr<const Gdk::Pixbuf> MarkAttributes::render_icon(Gtk::Widget* widget, int size) const
{

  Glib::RefPtr<const Gdk::Pixbuf> retvalue = Glib::wrap(const_cast<GdkPixbuf*>(gtk_source_mark_attributes_render_icon(const_cast<GtkSourceMarkAttributes*>(gobj()), (GtkWidget*)Glib::unwrap(widget), size)));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;

}

Glib::ustring MarkAttributes::get_tooltip_text(const Glib::RefPtr<Mark>& mark) const
{
  return Glib::convert_return_gchar_ptr_to_ustring(gtk_source_mark_attributes_get_tooltip_text(const_cast<GtkSourceMarkAttributes*>(gobj()), Glib::unwrap(mark)));
}

Glib::ustring MarkAttributes::get_tooltip_markup(const Glib::RefPtr<Mark>& mark) const
{
  return Glib::convert_return_gchar_ptr_to_ustring(gtk_source_mark_attributes_get_tooltip_markup(const_cast<GtkSourceMarkAttributes*>(gobj()), Glib::unwrap(mark)));
}


Glib::SignalProxy1< Glib::ustring,const Glib::RefPtr<Mark>& > MarkAttributes::signal_query_tooltip_text()
{
  return Glib::SignalProxy1< Glib::ustring,const Glib::RefPtr<Mark>& >(this, &MarkAttributes_signal_query_tooltip_text_info);
}


Glib::SignalProxy1< Glib::ustring,const Glib::RefPtr<Mark>& > MarkAttributes::signal_query_tooltip_markup()
{
  return Glib::SignalProxy1< Glib::ustring,const Glib::RefPtr<Mark>& >(this, &MarkAttributes_signal_query_tooltip_markup_info);
}


#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<Gdk::RGBA> MarkAttributes::property_background() 
{
  return Glib::PropertyProxy<Gdk::RGBA>(this, "background");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<Gdk::RGBA> MarkAttributes::property_background() const
{
  return Glib::PropertyProxy_ReadOnly<Gdk::RGBA>(this, "background");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<std::string> MarkAttributes::property_stock_id() 
{
  return Glib::PropertyProxy<std::string>(this, "stock-id");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<std::string> MarkAttributes::property_stock_id() const
{
  return Glib::PropertyProxy_ReadOnly<std::string>(this, "stock-id");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy< Glib::RefPtr<Gdk::Pixbuf> > MarkAttributes::property_pixbuf() 
{
  return Glib::PropertyProxy< Glib::RefPtr<Gdk::Pixbuf> >(this, "pixbuf");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Pixbuf> > MarkAttributes::property_pixbuf() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Pixbuf> >(this, "pixbuf");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<std::string> MarkAttributes::property_icon_name() 
{
  return Glib::PropertyProxy<std::string>(this, "icon-name");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<std::string> MarkAttributes::property_icon_name() const
{
  return Glib::PropertyProxy_ReadOnly<std::string>(this, "icon-name");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy< Glib::RefPtr<Gio::Icon> > MarkAttributes::property_gicon() 
{
  return Glib::PropertyProxy< Glib::RefPtr<Gio::Icon> >(this, "gicon");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gio::Icon> > MarkAttributes::property_gicon() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gio::Icon> >(this, "gicon");
}
#endif //GLIBMM_PROPERTIES_ENABLED


} // namespace Gsv


